{"version":3,"sources":["../src/codec/base64Url.ts","../src/codec/codec.ts","../src/codec/encrypt.ts","../src/codec/stash.ts","../src/codec/superJson.ts","../src/error.ts","../src/sorting.ts","../src/cursor.ts","../src/dialect/mssql.ts","../src/dialect/mysql.ts","../src/dialect/postgres.ts","../src/dialect/sqlite.ts","../src/paginator.ts"],"names":["crypto","randomUUID","superjson","z","createHash"],"mappings":"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","file":"index.cjs","sourcesContent":["import type { Codec } from './codec.js'\n\n/**\n * Base64 string codec. URL friendly\n */\nexport const base64UrlCodec: Codec<string, string> = {\n  encode: (s) => Buffer.from(s, 'utf8').toString('base64url'),\n  decode: (s) => Buffer.from(s, 'base64url').toString('utf8'),\n}\n","/**\n * A bidirectional transformer between two value types: input `I` and output `O`.\n *\n * @template I The type accepted by `encode` and produced by `decode`.\n * @template O The type produced by `encode` and accepted by `decode`.\n *\n * @property {(value: I) => Promise<O> | O} encode\n * Transform an input value `I` into an output value `O`. May be sync or async.\n *\n * @property {(value: O) => Promise<I> | I} decode\n * Inverse transform: turn an output value `O` back into an input value `I`. May be sync or async.\n */\nexport type Codec<I = any, O = any> = {\n  encode: (value: I) => Promise<O> | O\n  decode: (value: O) => Promise<I> | I\n}\n\ntype InOf<C> = C extends Codec<infer I, any> ? I : never\ntype OutOf<C> = C extends Codec<any, infer O> ? O : never\n\ntype First<T extends readonly unknown[]> = T extends readonly [infer F, ...unknown[]] ? F : never\ntype Last<T extends readonly unknown[]> = T extends readonly [...unknown[], infer L] ? L : never\n\ntype Composable<Cs extends readonly Codec[]> = Cs extends readonly []\n  ? true\n  : Cs extends readonly [Codec]\n    ? true\n    : Cs extends readonly [infer A, infer B, ...infer R]\n      ? A extends Codec<any, infer AO>\n        ? B extends Codec<infer BI, any>\n          ? [AO] extends [BI]\n            ? Composable<[B, ...(R extends readonly Codec[] ? R : never)]>\n            : false\n          : false\n        : false\n      : false\n\n/**\n * Compose a non-empty list of codecs into a single codec.\n * Validates that the codecs are type-composable: the input of each codec must be the output of the previous.\n *\n * - `encode` runs **left → right** through the provided codecs.\n * - `decode` runs **right → left** (the inverse order).\n *\n * @template Cs A non-empty readonly tuple of codecs to compose.\n * @param {...Cs} codecs The codecs to compose, in the order their `encode` functions should run.\n * @returns Codec<InOf<First<Cs>>, OutOf<Last<Cs>>> A codec representing the composition, or `never` if the codecs are not type-composable.\n */\nexport const codecPipe = <Cs extends readonly [Codec, ...Codec[]]>(...codecs: Cs) =>\n  ({\n    encode: (value) => codecs.reduce((acc, codec) => acc.then((v) => codec.encode(v)), Promise.resolve(value)),\n    decode: (value) => codecs.reduceRight((acc, codec) => acc.then((v) => codec.decode(v)), Promise.resolve(value)),\n  }) as Composable<Cs> extends true ? Codec<InOf<First<Cs>>, OutOf<Last<Cs>>> : never\n","import crypto from 'crypto'\n\nimport type { Codec } from './codec.js'\n\n/**\n * AES-256-GCM string codec using scrypt-derived keys.\n *\n * ## Usage\n * ```ts\n * const codec = createAesCodec(process.env.SECRET!);\n *\n * const encrypted = await codec.encode(\"hello\");\n * const decrypted = await codec.decode(encrypted);\n * ```\n *\n * ## Notes\n * - Uses `scrypt` (N=2^15, r=8, p=1) to derive a 256-bit key from `secret` + random 16-byte salt.\n * - Encrypts with random 12-byte IV and includes a 16-byte auth tag.\n * - Payload = Base64 of `[1-byte ver][salt][iv][tag][ciphertext]`.\n * - Tampering or wrong secret throws on decode.\n * - Works in Node.js with built-in `crypto`.\n *\n * @param secret - The secret key to use for the codec.\n * @returns The codec.\n */\nexport const createAesCodec = (secret: string): Codec<string, string> => {\n  const VERSION = Buffer.from([1])\n  const SALT_LEN = 16\n  const IV_LEN = 12\n  const TAG_LEN = 16\n  const KEY_LEN = 32\n  const SCRYPT_N = 1 << 15,\n    SCRYPT_r = 8,\n    SCRYPT_p = 1\n\n  const kdf = (salt: Buffer) =>\n    new Promise<Buffer>((resolve, reject) => {\n      crypto.scrypt(\n        secret,\n        salt,\n        KEY_LEN,\n        { N: SCRYPT_N, r: SCRYPT_r, p: SCRYPT_p, maxmem: 256 * 1024 * 1024 },\n        (err, dk) => (err ? reject(err) : resolve(dk as Buffer)),\n      )\n    })\n\n  const concat = (...parts: Buffer[]) => Buffer.concat(parts)\n\n  return {\n    encode: async (plain: string): Promise<string> => {\n      const salt = crypto.randomBytes(SALT_LEN)\n      const key = await kdf(salt)\n      const iv = crypto.randomBytes(IV_LEN)\n\n      try {\n        const cipher = crypto.createCipheriv('aes-256-gcm', key, iv)\n        const aad = concat(VERSION, salt)\n\n        cipher.setAAD(aad, {\n          plaintextLength: Buffer.byteLength(plain, 'utf8'),\n        })\n\n        const ciphertext = concat(cipher.update(plain, 'utf8'), cipher.final())\n        const tag = cipher.getAuthTag()\n\n        return concat(VERSION, salt, iv, tag, ciphertext).toString('base64')\n      } finally {\n        key.fill(0)\n      }\n    },\n\n    decode: async (payload: string): Promise<string> => {\n      const buf = Buffer.from(payload, 'base64')\n      const HEADER = 1 + SALT_LEN + IV_LEN + TAG_LEN\n      if (buf.length < HEADER) throw new Error('Invalid payload: too short')\n\n      const ver = buf.subarray(0, 1)\n      if (ver[0] !== 1) throw new Error(`Unsupported version: ${ver[0]}`)\n\n      const salt = buf.subarray(1, 1 + SALT_LEN)\n      const iv = buf.subarray(1 + SALT_LEN, 1 + SALT_LEN + IV_LEN)\n      const tag = buf.subarray(1 + SALT_LEN + IV_LEN, HEADER)\n      const ciphertext = buf.subarray(HEADER)\n\n      const key = await kdf(salt)\n      try {\n        const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv)\n        const aad = concat(ver, salt)\n\n        decipher.setAAD(aad, { plaintextLength: ciphertext.length })\n        decipher.setAuthTag(tag)\n\n        const plaintext = concat(decipher.update(ciphertext), decipher.final())\n        return plaintext.toString('utf8')\n      } finally {\n        key.fill(0)\n      }\n    },\n  }\n}\n","import { randomUUID } from 'crypto'\n\nimport type { Codec } from './codec.js'\n\n/**\n * A simple asynchronous key-value storage interface.\n *\n * Each key and value must be a string.\n * Implementations could be in-memory, filesystem-based, Redis-backed, etc.\n */\nexport type Stash = {\n  /**\n   * Retrieve a value by key.\n   * @param key The key to retrieve.\n   * @returns The value.\n   */\n  get: (key: string) => Promise<string>\n  /**\n   * Store a value under a specific key.\n   * @param key The key to store the value under.\n   * @param value The value to store.\n   */\n  set: (key: string, value: string) => Promise<void>\n}\n\n/**\n * Creates a {@link Codec} that encodes strings into stash keys and decodes keys back into their stored strings.\n *\n * - **encode(value)**: stores the given string `value` in the provided {@link Stash} under a randomly generated UUID key.\n *   Returns the generated key.\n * - **decode(key)**: retrieves and returns the original string value stored under `key`.\n *\n * This is useful for scenarios where you want to replace large or sensitive strings\n * with short unique identifiers and retrieve them later.\n *\n * @param stash The stash instance to use for storage and retrieval.\n */\nexport const stashCodec = (stash: Stash): Codec<string, string> => ({\n  decode: (value) => stash.get(value),\n  encode: async (value) => {\n    const key = randomUUID()\n    await stash.set(key, value)\n    return key\n  },\n})\n","import superjson from 'superjson'\n\nimport type { Codec } from './codec.js'\n\n/**\n * SuperJSON object codec.\n * Superjson is used to preserve types like Date & BigInt\n */\nexport const superJsonCodec: Codec<unknown, string> = {\n  encode: (value) => superjson.stringify(value),\n  decode: (value) => superjson.parse(value),\n}\n","export type ErrorCode = 'INVALID_TOKEN' | 'INVALID_SORT' | 'INVALID_LIMIT' | 'UNEXPECTED_ERROR'\n\ntype ErrorOpts = {\n  message: string\n  code: ErrorCode\n  cause?: Error\n}\n\nexport class PaginationError extends Error {\n  code: ErrorCode\n\n  constructor(opts: ErrorOpts) {\n    super(opts.message, { cause: opts.cause })\n    this.code = opts.code\n  }\n}\n","import type { OrderByDirection, ReferenceExpression, StringReference } from 'kysely'\n\ntype MatchingKeys<Obj, M> = Extract<\n  {\n    [K in keyof Obj]-?: Obj[K] extends M ? K : never\n  }[keyof Obj],\n  string\n>\n\ntype OptionallyQualified<TB, O, Allowed> = TB extends string\n  ? MatchingKeys<O, Allowed> | `${TB}.${MatchingKeys<O, Allowed>}`\n  : never\n\nexport const applyDefaultDirection = (dir: OrderByDirection | undefined | null): OrderByDirection => dir ?? 'asc'\n\nexport type SortItem<DB, TB extends keyof DB, O, Allowed> = {\n  dir?: OrderByDirection\n} & (\n  | {\n      col: ReferenceExpression<DB, TB>\n      output: MatchingKeys<O, Allowed>\n    }\n  | {\n      col: StringReference<DB, TB> & OptionallyQualified<TB, O, Allowed>\n    }\n)\n\ntype Sortable = string | number | boolean | Date | bigint\n\nexport type SortSet<DB, TB extends keyof DB, O> = readonly [\n  ...SortItem<DB, TB, O, Sortable | null>[], // nullable leading sorts\n  SortItem<DB, TB, O, Sortable>, // non-null final sort\n]\n","import { createHash } from 'crypto'\nimport type { ExpressionBuilder, ExpressionWrapper, ReferenceExpression, SelectQueryBuilder, SqlBool } from 'kysely'\nimport { z } from 'zod'\n\nimport type { Codec } from './codec/codec.js'\nimport { PaginationError } from './error.js'\nimport type { SortItem, SortSet } from './sorting.js'\nimport { applyDefaultDirection } from './sorting.js'\n\nconst CursorPayloadSchema = z.object({\n  sig: z.string(),\n  k: z.record(z.string(), z.any()),\n})\nexport type CursorPayload = z.output<typeof CursorPayloadSchema>\n\nexport type CursorIncoming = { nextPage: string } | { prevPage: string } | { offset: number }\n\nexport type DecodedCursorNextPrev = {\n  type: 'next' | 'prev'\n  payload: CursorPayload\n}\n\nexport type DecodedOffset = {\n  type: 'offset'\n  offset: number\n}\n\nexport type DecodedCursor = DecodedCursorNextPrev | DecodedOffset\n\nexport type CursorOutgoing = {\n  startCursor?: string\n  endCursor?: string\n  nextPage?: string\n  prevPage?: string\n}\n\nexport const decodeCursor = async (cursor: CursorIncoming, keysetCodec: Codec<any, string>): Promise<DecodedCursor> => {\n  if ('nextPage' in cursor)\n    return {\n      type: 'next',\n      payload: await decodeCursorPayload(cursor.nextPage, keysetCodec),\n    }\n  if ('prevPage' in cursor)\n    return {\n      type: 'prev',\n      payload: await decodeCursorPayload(cursor.prevPage, keysetCodec),\n    }\n  if ('offset' in cursor) return { type: 'offset', offset: cursor.offset }\n\n  throw new PaginationError({ message: 'Invalid cursor', code: 'INVALID_TOKEN' })\n}\n\nconst decodeCursorPayload = async (token: string, keysetCodec: Codec<any, string>) => {\n  const decoded = await keysetCodec.decode(token)\n  return CursorPayloadSchema.parse(decoded)\n}\n\nexport const resolvePageTokens = async (\n  rows: object[],\n  sorts: SortSet<any, any, any>,\n  cursorCodec: Codec<any, string>,\n  decodedCursor: DecodedCursor | null,\n  overFetched: boolean,\n): Promise<CursorOutgoing> => {\n  // if no rows, we return no tokens\n  if (rows.length === 0) return {}\n\n  const inverted = decodedCursor?.type === 'prev'\n  const isFirst = !decodedCursor || (decodedCursor.type === 'offset' && decodedCursor.offset === 0)\n\n  const first = rows.at(0)\n  const last = rows.at(-1)\n\n  const startCursor = first ? await cursorCodec.encode(resolveCursor(first, sorts)) : undefined\n  const endCursor = last ? await cursorCodec.encode(resolveCursor(last, sorts)) : undefined\n\n  return {\n    startCursor,\n    endCursor,\n    prevPage: (!inverted || overFetched) && !isFirst ? startCursor : undefined,\n    nextPage: inverted || overFetched ? endCursor : undefined,\n  }\n}\n\nexport type EdgeOutgoing<T> = {\n  node: T\n  cursor: string\n}\n\nexport const resolveEdges = async <O>(\n  rows: O[],\n  sorts: SortSet<any, any, any>,\n  cursorCodec: Codec<any, string>,\n): Promise<EdgeOutgoing<O>[]> => {\n  // if no rows, return no edges\n  if (rows.length === 0) return []\n\n  return await Promise.all(\n    rows.map(async (row) => {\n      const cursor = await cursorCodec.encode(resolveCursor(row, sorts))\n      return { node: row, cursor }\n    }),\n  )\n}\n\nexport const getSortOutput = (sort: SortItem<any, any, any, any>) =>\n  'output' in sort ? sort.output : sort.col.split('.').at(-1)!\n\nexport const sortSignature = (sorts: SortSet<any, any, any>) => {\n  const sig = sorts.map((s) => `${'output' in s ? s.output : s.col}:${s.dir ?? 'asc'}`).join('|')\n  return createHash('sha256').update(sig).digest('hex').slice(0, 8)\n}\n\nexport const resolveCursor = (item: any, sorts: SortSet<any, any, any>) => {\n  const sig = sortSignature(sorts)\n\n  const k = Object.fromEntries(\n    sorts.map((s) => {\n      const key = getSortOutput(s)\n      return [key, item[key]]\n    }),\n  )\n\n  return { sig, k }\n}\n\nexport const buildCursorPredicateRecursive = <DB, TB extends keyof DB, S extends SortSet<any, any, any>>(\n  eb: ExpressionBuilder<DB, TB>,\n  sorts: S,\n  decoded: CursorPayload,\n  idx = 0,\n): ExpressionWrapper<DB, TB, SqlBool> => {\n  const sort = sorts[idx]\n  if (!sort) throw new PaginationError({ message: 'Sort index out of bounds', code: 'UNEXPECTED_ERROR' })\n\n  const dir = applyDefaultDirection(sort.dir)\n  const col = sort.col as ReferenceExpression<DB, TB>\n  const key = getSortOutput(sort)\n  if (!(key in decoded.k))\n    throw new PaginationError({\n      message: `Missing pagination cursor value for \"${key}\"`,\n      code: 'INVALID_TOKEN',\n    })\n\n  const value = decoded.k[key]\n  const cmp = dir === 'desc' ? '<' : '>'\n\n  if (idx === sorts.length - 1) {\n    // last sort: tie-breaker\n    return eb(col, cmp, value)\n  }\n\n  // recursively build predicate for the next sort field\n  const next = buildCursorPredicateRecursive(eb, sorts, decoded, idx + 1)\n\n  if (value === null)\n    // handle NULLs explicitly since SQL ordering treats them specially\n    return dir === 'asc'\n      ? eb.or([eb(col, 'is', null).and(next), eb(col, 'is not', null)])\n      : eb.and([eb(col, 'is', null), next])\n\n  // combine current column comparison with recursion for tie-breaking\n  return eb.or([\n    eb(col, cmp, value), // current column moves cursor forward\n    eb.and([eb(col, '=', value), next]), // tie on current col → check next one\n    ...(dir === 'desc' ? [eb(col, 'is', null)] : []), // include NULLs in DESC order\n  ])\n}\n\nexport const baseApplyCursor = <DB, TB extends keyof DB, O>(\n  builder: SelectQueryBuilder<DB, TB, O>,\n  sorts: SortSet<DB, TB, O>,\n  cursor: DecodedCursorNextPrev,\n) => builder.where((eb) => buildCursorPredicateRecursive(eb, sorts, cursor.payload))\n","import type { OrderByExpression, SelectQueryBuilder } from 'kysely'\n\nimport { baseApplyCursor } from '../cursor.js'\nimport type { SortSet } from '../sorting.js'\nimport type { PaginationDialect } from '../types.js'\n\n/**\n * A dialect for SQL Server\n */\nexport const MssqlPaginationDialect: PaginationDialect = {\n  applyLimit: (builder, limit, cursorType) => (cursorType === 'offset' ? builder.fetch(limit) : builder.top(limit)),\n\n  applyOffset: (builder, offset) => builder.offset(offset),\n\n  applySort: <DB, TB extends keyof DB, O>(builder: SelectQueryBuilder<DB, TB, O>, sorts: SortSet<DB, TB, O>) => {\n    for (const s of sorts) {\n      const dir = s.dir ?? 'asc'\n\n      builder = builder.orderBy(s.col as OrderByExpression<DB, TB, O>, dir)\n    }\n\n    return builder\n  },\n\n  applyCursor: baseApplyCursor,\n}\n","import type { OrderByExpression, SelectQueryBuilder } from 'kysely'\n\nimport { baseApplyCursor } from '../cursor.js'\nimport type { SortSet } from '../sorting.js'\nimport type { PaginationDialect } from '../types.js'\n\n/**\n * A dialect for MySQL\n */\nexport const MysqlPaginationDialect: PaginationDialect = {\n  applyLimit: (builder, limit) => builder.limit(limit),\n\n  applyOffset: (builder, offset) => builder.offset(offset),\n\n  applySort: <DB, TB extends keyof DB, O>(builder: SelectQueryBuilder<DB, TB, O>, sorts: SortSet<DB, TB, O>) => {\n    for (const s of sorts) {\n      const dir = s.dir ?? 'asc'\n\n      builder = builder.orderBy(s.col as OrderByExpression<DB, TB, O>, dir)\n    }\n\n    return builder\n  },\n\n  applyCursor: baseApplyCursor,\n}\n","import type { OrderByExpression, SelectQueryBuilder } from 'kysely'\n\nimport { baseApplyCursor } from '../cursor.js'\nimport type { SortSet } from '../sorting.js'\nimport type { PaginationDialect } from '../types.js'\n\n/**\n * A dialect for PostgreSQL\n */\nexport const PostgresPaginationDialect: PaginationDialect = {\n  applyLimit: (builder, limit) => builder.limit(limit),\n\n  applyOffset: (builder, offset) => builder.offset(offset),\n\n  applySort: <DB, TB extends keyof DB, O>(builder: SelectQueryBuilder<DB, TB, O>, sorts: SortSet<DB, TB, O>) => {\n    for (const s of sorts) {\n      const dir = s.dir ?? 'asc'\n\n      builder = builder.orderBy(s.col as OrderByExpression<DB, TB, O>, (a) =>\n        dir === 'asc' ? a.asc().nullsFirst() : a.desc().nullsLast(),\n      )\n    }\n\n    return builder\n  },\n\n  applyCursor: baseApplyCursor,\n}\n","import type { OrderByExpression, SelectQueryBuilder } from 'kysely'\n\nimport { baseApplyCursor } from '../cursor.js'\nimport type { SortSet } from '../sorting.js'\nimport type { PaginationDialect } from '../types.js'\n\n/**\n * A dialect for SQLite\n */\nexport const SqlitePaginationDialect: PaginationDialect = {\n  applyLimit: (builder, limit) => builder.limit(limit),\n\n  applyOffset: (builder, offset) => builder.offset(offset),\n\n  applySort: <DB, TB extends keyof DB, O>(builder: SelectQueryBuilder<DB, TB, O>, sorts: SortSet<DB, TB, O>) => {\n    for (const s of sorts) {\n      const dir = s.dir ?? 'asc'\n\n      builder = builder.orderBy(s.col as OrderByExpression<DB, TB, O>, dir)\n    }\n\n    return builder\n  },\n\n  applyCursor: baseApplyCursor,\n}\n","import { base64UrlCodec } from './codec/base64Url.js'\nimport { codecPipe } from './codec/codec.js'\nimport { superJsonCodec } from './codec/superJson.js'\nimport { decodeCursor, resolveEdges, resolvePageTokens, sortSignature } from './cursor.js'\nimport { PaginationError } from './error.js'\nimport type { SortSet } from './sorting.js'\nimport { applyDefaultDirection } from './sorting.js'\nimport type { PaginateArgs, PaginatedResult, PaginatedResultWithEdges, Paginator, PaginatorOptions } from './types.js'\n\nconst DEFAULT_CURSOR_CODEC = codecPipe(superJsonCodec, base64UrlCodec)\n\nexport const createPaginator = (opts: PaginatorOptions): Paginator => ({\n  paginate: (args) => paginate({ ...args, ...opts }),\n  paginateWithEdges: (args) => paginateWithEdges({ ...args, ...opts }),\n})\n\nexport const paginate = async <DB, TB extends keyof DB, O, S extends SortSet<DB, TB, O>>({\n  query,\n  sorts,\n  limit,\n  cursor,\n  dialect,\n  cursorCodec = DEFAULT_CURSOR_CODEC,\n}: PaginateArgs<DB, TB, O, S> & PaginatorOptions): Promise<PaginatedResult<O>> => {\n  assertLimitSorts(limit, sorts)\n\n  try {\n    const decodedCursor = cursor ? await decodeCursor(cursor, cursorCodec) : null\n    const sortsApplied = decodedCursor?.type === 'prev' ? invertSorts(sorts) : sorts\n\n    let q = dialect.applySort(query, sortsApplied)\n    q = dialect.applyLimit(q, limit + 1, decodedCursor?.type)\n\n    if (decodedCursor) {\n      if (decodedCursor.type === 'offset') {\n        q = dialect.applyOffset(q, decodedCursor.offset)\n      } else {\n        const sig = sortSignature(sorts)\n        if (decodedCursor.payload.sig !== sig)\n          throw new PaginationError({ message: 'Page token does not match sort order', code: 'INVALID_TOKEN' })\n\n        q = dialect.applyCursor(q, sortsApplied, decodedCursor)\n      }\n    }\n\n    const rows = await q.execute()\n\n    const items = decodedCursor?.type === 'prev' ? rows.slice(0, limit).reverse() : rows.slice(0, limit)\n\n    const { startCursor, endCursor, prevPage, nextPage } = await resolvePageTokens(\n      items,\n      sorts,\n      cursorCodec,\n      decodedCursor,\n      rows.length > limit,\n    )\n\n    return {\n      items,\n      prevPage,\n      nextPage,\n      startCursor,\n      endCursor,\n      hasPrevPage: !!prevPage,\n      hasNextPage: !!nextPage,\n    }\n  } catch (error) {\n    if (error instanceof PaginationError) throw error\n    throw new PaginationError({ message: 'Failed to paginate', cause: error as Error, code: 'UNEXPECTED_ERROR' })\n  }\n}\n\nexport const paginateWithEdges = async <DB, TB extends keyof DB, O, S extends SortSet<DB, TB, O>>(\n  args: PaginateArgs<DB, TB, O, S> & PaginatorOptions,\n): Promise<PaginatedResultWithEdges<O>> => {\n  const { sorts, cursorCodec = DEFAULT_CURSOR_CODEC } = args\n  const { items, ...paginated } = await paginate(args)\n\n  try {\n    const edges = await resolveEdges(items, sorts, cursorCodec)\n\n    return {\n      ...paginated,\n      edges,\n    }\n  } catch (error) {\n    if (error instanceof PaginationError) throw error\n    throw new PaginationError({ message: 'Failed to generate edges', cause: error as Error, code: 'UNEXPECTED_ERROR' })\n  }\n}\n\nconst assertLimitSorts = (limit: number, sorts: readonly unknown[]) => {\n  if (!(Number.isInteger(limit) && limit > 0))\n    throw new PaginationError({ message: 'Invalid page size limit', code: 'INVALID_LIMIT' })\n  if (!Array.isArray(sorts) || sorts.length < 1)\n    throw new PaginationError({ message: 'Cannot paginate without sorting', code: 'INVALID_SORT' })\n}\n\nconst invertSorts = <S extends SortSet<any, any, any>>(sorts: S): S =>\n  sorts.map((s) => ({\n    ...s,\n    dir: applyDefaultDirection(s.dir) === 'desc' ? 'asc' : 'desc',\n  })) as unknown as S\n"]}